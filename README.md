# EvtsJS
A small library that adds powerful custom events.

## Including EvtsJS in Projects
### HTML
```html
<script src="https://cdn.jsdelivr.net/gh/paulkanja/evtsjs@main/es6/Evts.js"></script>
```
### ES6 Module
```js
import Evt from "https://cdn.jsdelivr.net/gh/paulkanja/evtsjs@main/es6/Evts.mjs";
```

## Using EvtsJS
### Creating Events
Events can be created by using `new` to construct an instance of the `Evt` class:
```js
const evt = new Evt("my-event");
```
The event's name can be accessed using its `name` property:
```js
evt.name; // "my-evt"
```
### Event Handlers
Handlers are functions that are called when an event is fired. They can be added to an event by using the `addHandler` method:
```js
evt.addHandler(handler);
```
Multiple handlers can be added to an event using the `addHandlers` method or the `on` method:
```js
evt.addHandlers(handler1, handler2, handler3, ...);

evt.on(handler1, handler2, handler3, ...);
```

When an event is fired, handlers receive an object with properties related to the firing. These properties are:
* `caller`: The object that fired the event.
* `evt`: The event called.
* `data`: Data passed when firing the event.
* `time`: The time the event was fired.
The object also has a method `cancel`. When this method is called, it prevents all other handlers after this one from being called.
### Priority Handlers
Priority handlers are handlers that are called before the normal handlers are called. This means they are unaffected by cancels from normal handlers. To add a function as a priority handler to an event, the `addPriorityHandler` method is used:
```js
evt.addPriorityHandler(handler);
```
Multiple priority handlers can be added to an event using the `addPriorityHandlers` method:
```js
evt.addPriorityHandlers(handler1, handler2, handler3, ...);
```
### Removing Handlers
A handler can be removed from an event using the `removeHandler` method. Multiple handlers can be removed using the `removedHandlers` method. Priority handlers are handled by the `removePriorityHandler` and `removePriorityHandlers` methods.
```js
evt.removeHandler(handler);
evt.removeHandlers(handler1, handler2, handler3, ...);

evt.removePriorityHandler(handler);
evt.removePriorityHandlers(handler1, handler2, handler3, ...);
```
All handlers on an event can be removed using the `clearHandlers` method. `clearPriorityHandlers` removes all priority handlers on an event.
```js
evt.clearHandlers();

evt.clearPriorityHandlers()
```
### Locking and Unlocking Events
Events can be locked to prevent other parties from editing important parts of the event and from firing the event. This is done by calling the `lock` method:
```js
evt.lock();
```
Locking an event prevents the firing of the event as well as the editing of the event's priority handlers list (i.e. adding handlers, removing handlers, or clearing the list). Normal handlers can still be added or removed. However, completely locking out most functions is not useful. The `lock` method returns a key that can be used to bypass this restriction. All sensitive functions accept a key as the first argument. If the correct key is provided, the function is executed even if the event is locked.
```js
const key = evt.lock();
evt.addPriorityHandler(handler); // does not work
evt.addPriorityHandler(key, handler); // works
```
Locking an event can be reversed by passing the event's key to the `unlock` method:
```js
evt.unlock(key);
```
The locked status of an event can be read using the readonly `locked` property:
```js
evt.locked; // false;

evt.lock();

evt.locked; // true;
```
Calling the `lock` method on a locked event does nothing.
```js
const key = evt.lock();

const key2 = evt.lock(); // null

evt.unlock(key2); // does not work
```
**Note**: The key returned by the `lock` method is a [`Symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol). That means the key generated by each call of the `lock` method is unique and cannot be reused if the event is unlocked and locked again.
```js
const key = evt.lock();

evt.unlock(key); // works

evt.lock(); // generates a new key

evt.unlock(key); // does not work; this key is now invalid
```
### Firing Events
Events are fired using the `call` method. This method has the following parameters:
* `key`: Unlike other Evt methods, the starting `key` parameter cannot be omitted when calling `call`. For events that are not locked, passing any value, including `null` and `undefined` will be considered valid.
* `caller`: The object that fired the event. The default is `null`.
* `data`: Extra data to be passed to the handlers. The default is `null`.
* `opts`: Options used to override data to be passed to the handlers. The default is an empty object `{}`:
    * `overrideEvt`: An `Evt` object to override the `evt` data passed to the handlers. The `evt` data is the fired `Evt` by default.
    * `overrideTime`: An integer `number` to override the `time` data passed to the handlers.
```js
evt.call(key, caller, data, {overrideEvt, overrideTime});
```
**Note**: An event cannot be fired while it's `call` method is still running. This prevents circular references that may lead to infinite recursion. To check whether an event's call method is currently being executed, the `pending` property is used:
```js
evt.pending; // false

evt.addHandler(e =>
{
    console.log(evt.pending); // true
    evt.call(); // will not work;
});

evt.call();
```
